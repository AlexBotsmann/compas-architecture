<!--
SPDX-FileCopyrightText: 2021 Alliander N.V.

SPDX-License-Identifier: CC-BY-4.0
-->

# Технологія

На цій сторінці перераховані технології та інструменти, вибрані для проєкту

![Current technology choices](./images/current_technology_overview/Current_Technology_Choices_Overview.png)

# Вибори Технологій
## Мова програмування - Java
В якості мови програмування обрано Java 17.
- Java добре відома в енергетиці
- Розробники доступні
- Java знайома в проектах LFE

## Java середа розробки - Maven
Для створення програм ми використовуємо Maven. Maven добре підтримується в CI/CD.

## Розгортання мікросервісів у Docker
Мікросервіси розгортаються як контейнер Docker на базі Linux. Переваги розгортання в контейнері Docker:

- Розгортання не залежить від платформи розгортання/ОС
- Добре підтримується для хмарного розгортання
- Доступні інструменти
- Відкритий код
- Масштабований, резервований
- Образи можна легко поширювати


## База даних - BaseX
База даних [BaseX](https://basex.org/) обрана за слідуючима аргументами:

**Pros**
- Місцева база даних XML 
- Повністю відкриті джерела
- BSD ліцензія
- Легко встановлювати використовуючи доступні Образи Docker
- Доступна кросплатформність
- Активна спільнота
- Множина API, таких як REST(ful) і HTTP
- [ACID guarantees](https://docs.basex.org/wiki/Transaction_Management)
- Багато [прикладів використовування](https://docs.basex.org/wiki/Clients) доступно на різних мовах програмування

**Cons**
- Немає чітких випадків використання BaseX
- Контроль версій не доступний із коробки. Необхідно використовувати другу базу даних для створення «керування версіями», що створює архівну базу даних і поточну базу даних. І за допомогою RESTXQ відносно легко створити механізм керування версіями. [SirixDB](https://sirix.io/) буде гарна альтернатива BaseX, якщо нам потрібна база даних NoSQL із механізмом керування версіями.

## XML Processing 
### XML Валідація

**Schematron**

SCL XSD є базовою схемою для перевірки файлу SCL. Незважаючи на те, що з XSD 1.1 якимось чином можна визначити обмеження спільного входження за допомогою тегів "key", "keyref" (у поєднанні з селектором xpath) і правила обмеження за допомогою "assert" (у визначенні типу), цього недостатньо для виражена складна та індивідуальна бізнес-логіка.

Schematron — це мова перевірки на основі правил для створення тверджень про наявність або відсутність шаблонів у деревах XML. Для використання Schematron не потрібне важке середовище.
Schematron — це XML, використовує технології xml (XPATH) і дуже простий (менше семи основних елементів)
Він має функції обробки XML, яких немає в інших валідаторах схем:
- перевірка міждокументних обмежень,
- підказка для виправлення файлу під перевіркою.
- Перевірка фази/профілю
- Визначення абстрактних правил, які можна розширити (успадкування)
- Можливість вбудовування в схему XSD і Relax NG
- тощо.

Оптимально використовувати в поєднанні зі схемою XML (XSD, RELAX NG).. 

### Java frameworks для XML processing
**Pros JAXB**
- JAXB (Java Architecture for XML Binding) це фреймворк, який дозволяє відображати класи Java на представлення XML
- Ефективне використовування пам'яті (більше інформації можна переглянути в порівнянні з [CIM - 61850 Mapping technologies](archive/CIM_61850_MAPPING_MVP.md))
- Використовує XJC інструменти, що доступні на JDK, який компілює файл схеми XML у класи Java, анотовані анотаціями JAXB, придатними для (не)маршалінгу. Таким чином файл XML можна легко створити, вставивши дані в моделі.

**Cons JAXB**
- JAXB була частиною мови Java, але видалена з мови починаючи від Java version 11. Щоб використовувати його, вам потрібно додати додаткову залежність.
- Працювати з великими документами непросто (cf. [JAXB user guide](https://javaee.github.io/jaxb-v2/doc/user-guide/ch03.html#unmarshalling-dealing-with-large-documents).) 

### Бібліотеки Java для schematron

- [schematron-ant](https://github.com/Schematron/ant-schematron)
- [schematron-basex](https://github.com/Schematron/schematron-basex)
- [schematron-exist](https://github.com/Schematron/schematron-exist)
- [ph-schematron](https://github.com/phax/ph-schematron/wiki)
- [apache camel](https://camel.apache.org/components/3.7.x/schematron-component.html) для корпоративної інтеграції шаблонного середовища

**Інші підтримки для техничних характеристик Schematron**

- [lxml](https://lxml.de/) (Python library)
- libxml2 (C XML library)

### RDF4J для IEC CIM файлів конфігурації 

**Pros RDF4J**
- Бібліотека Java для запиту RDF(XML) файлів
- Добре відома у Java спільноті
- Не потрібно "винаходити колесо" для обробки вхідних файлів конфігурації IEC CIM

**Cons RDF4J**
- Якщо у вас немає досвіду роботи з трійками, може знадобитися деякий час, перш ніж усе це зрозуміти.

### MapStruct

MapStruct це Java framework щоб робити мепінг даних. MapStruct, наприклад, використовується в CIM Mapping для відображення даних
між CIM класами та IEC 61850 класами. Більше інформації можна знайти на https://mapstruct.org/.

**Pros**
- Мепінг виконується на розділеному інтерфейсі (Mapper interface) з анотаціями
- Актиний проєкт на [GitHub](https://github.com/mapstruct/mapstruct)
- MapStruct проєкт знає Quarkus, дивиться цю [статтю](https://mapstruct.org/news/2019-12-06-mapstruct-and-quarkus/)
- Інтеграція з усіма видами [IDEs](https://mapstruct.org/documentation/ide-support/)
- Продуктивність також здається високою, оскільки не використовується відображенння, а згенеровані класи. 
[Baeldung Overview](https://www.baeldung.com/java-performance-mapping-frameworks)

**Cons**
- Для створення класів з інтерфейсу потрібен процесор анотацій у Maven

## Java framework - Quarkus
Для фреймворка що буде використовуватися з Java ми вибрали [Quarkus](https://quarkus.io/).

**Pros**
- Стек Java, досвід роботи доступний у спільноті
- Відкритий код
- Гаряче перезавантаження для швидкого розвитку
— Менш докладний код під час розробки REST API, порівняно, наприклад, з Java Spring
- Спеціально для GraalVM (універсальна віртуальна машина), що також дуже цікаво для нас (використання ресурсів)
— Значне зменшення обсягу пам’яті порівняно з традиційними хмарними стеками, такими як Java Spring.
- Величезне скорочення часу відповіді порівняно з традиційними хмарними стеками, такими як Java Spring.
- За підтримки RedHat
- Швидке налаштування мікросервісів за допомогою REST API

Дивлячись на використання пам’яті (і час відгуку) Quarkus, це безперечно цікаво для нас. Подивіться також на це [порівняння з Java Spring](https://simply-how.com/quarkus-vs-spring-boot-production-performance)

Оскільки CoMPAS — це програма, яка також має працювати локально, використання пам’яті є важливим аспектом. Разом з тим, що він є сучасним мікросервісним фреймворком із підтримкою RedHat і є фреймворком Java (з яким у нас є досвід), це найкращий вибір на даний момент!

**Cons**
- Не підтримує повний набір деяких стандартів EE, як-от Enterprise JavaBeans. Очікувано, що для нас це не порушує гру.
- Відносно нова технологія, фреймворк може містити деякі «початкові помилки». З іншого боку, численні дослідження стверджують зрілість рамок, досягнутих за цей короткий час.
- Небагато розробників знайомі з Quarkus порівняно з, напр. [Spring framework](https://spring.io/).

## Контроль джерел - GitHub
Ми обрали GitHub для контролю джерел. Це добра практика для відкритої розробки. 
Репозиторії CoMPAS можна знайти на [https://github.com/com-pas/](https://github.com/com-pas/) 

## CI/CD - GitHub actions
Ми обрали [GitHub Actions](https://github.com/features/actions) як механізм для CI/CD. 

**Pros**
- Майбутній інструмент, який дійсно активно розвивається
- Безкоштовний інструмент для загальнодоступних сховищ GitHub (яким є CoMPAS)
- Ідеально інтегрується з репозиторіями GitHub

**Cons**
- Програмне забезпечення є фірмовим
- У співрозробників зростає кількість адоптацій



# Рекомендація засобів
У цьому розділі наведено *рекомендовані* засоби розробки. Звичайно, розробники можуть вільно використовувати власні засоби розробки

## SDE - Microsoft Visual Studio Code
[Microsoft Visual Studio Code](https://code.visualstudio.com/) це універсальне середовище розробки, що підтримує багато мов. 

